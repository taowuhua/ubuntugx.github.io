<!DOCTYPE html><html><head><title>20160113</title><meta charset='utf-8'><link href='https://dn-maxiang.qbox.me/res-min/themes/marxico.css' rel='stylesheet'><style></style></head><body><div style="width:80%;margin: 0 auto;border: 1px solid rgba(0,0,0,.1);"><div id='preview-contents' class='note-content'>
                        <div id="wmd-preview" class="preview-content"></div>
                    <div id="wmd-preview-section-1" class="wmd-preview-section preview-content">

</div><div id="wmd-preview-section-2" class="wmd-preview-section preview-content">

<h1 id="20160113">20160113</h1>

</div><div id="wmd-preview-section-3" class="wmd-preview-section preview-content">

<h2 id="学习-typescript">继续继续学习 TypeScript</h2>

</div><div id="wmd-preview-section-4" class="wmd-preview-section preview-content">

<h4 id="复习前面的-accessors-存取器">复习前面的 accessors （存取器）</h4>

<p>In this version, we check to make sure the user has a secret passcode available before we allow them to modify the employee. We do this by replacing the direct access to fullName with a ‘set’ that will check the passcode. We add a corresponding ‘get’ to allow the previous example to continue to work seamlessly.  <br>
在这个例子里，在允许修改 employee 之前，我们先检查密码是否正确。我们把 fullname 的直接访问变成了检查密码的 set 方法。我们也加了一个 get 方法，上述例子仍然可以工作。</p>

</div><div id="wmd-preview-section-5" class="wmd-preview-section preview-content">

<pre class="prettyprint hljs-dark"><code class="language-typescript hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-keyword">var</span> passcode=<span class="hljs-string">"secret passcode"</span>;<br><span class="hljs-comment line-number">2.</span><span class="hljs-keyword">class</span> Employee{<br><span class="hljs-comment line-number">3.</span>    <span class="hljs-keyword">private</span> _fullname: <span class="hljs-built_in">string</span>;<br><span class="hljs-comment line-number">4.</span><br><span class="hljs-comment line-number">5.</span>    <span class="hljs-keyword">get</span> fullName():<span class="hljs-built_in">string</span> {<br><span class="hljs-comment line-number">6.</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._fullname;<br><span class="hljs-comment line-number">7.</span>    }<br><span class="hljs-comment line-number">8.</span>    <span class="hljs-keyword">set</span> fullName(newName: <span class="hljs-built_in">string</span>){<br><span class="hljs-comment line-number">9.</span>        <span class="hljs-keyword">if</span>(passcode &amp;&amp; passcode === <span class="hljs-string">"secret passcode"</span>){<br><span class="hljs-comment line-number">10.</span>            <span class="hljs-keyword">this</span>._fullname = newName;<br><span class="hljs-comment line-number">11.</span>        }<br><span class="hljs-comment line-number">12.</span>        <span class="hljs-keyword">else</span>{<br><span class="hljs-comment line-number">13.</span>            alert(<span class="hljs-string">"error,incorrect password"</span>);<br><span class="hljs-comment line-number">14.</span>        }<br><span class="hljs-comment line-number">15.</span>    }<br><span class="hljs-comment line-number">16.</span>}<br><span class="hljs-comment line-number">17.</span><span class="hljs-keyword">var</span> employee = <span class="hljs-keyword">new</span> Employee();<br><span class="hljs-comment line-number">18.</span>employee.fullName = <span class="hljs-string">"Bob Smith"</span>;  <span class="hljs-comment">// 像是调用了 set 方法</span><br><span class="hljs-comment line-number">19.</span><span class="hljs-keyword">if</span>(employee.fullName){            <span class="hljs-comment">// 像是调用了 get 方法</span><br><span class="hljs-comment line-number">20.</span>    alert(employee.fullName);<br><span class="hljs-comment line-number">21.</span>}<br></code></pre>

<p>To prove to ourselves that our accessor is now checking the passcode, we can modify the passcode and see that when it doesn’t match we instead get the alert box warning us we don’t have access to update the employee. <br>
Note: Accessors require you to set the compiler to output ECMAScript 5. <br>
我们可以修改密码，来证明存取器是否工作。当密码不对时，证明我们不能修改 employee。</p>

<ul><li><strong>Static Properties</strong>（静态属性） <br>
Up to this point, we’ve only talked about the instance members of the class, those that show up on the object when its instantiated. We can also create static members of a class, those that are visible on the class itself rather than on the instances. In this example, we use ‘static’ on the origin, as it’s a general value for all grids. Each instance accesses this value through prepending the name of the class. Similarly to prepending ‘this.’ in front of instance accesses, here we prepend ‘Grid.’ in front of static accesses. <br>
在前面的例子中，我们只讨论了类中实例化的成员，仅当类被实例化才会被初始化的属性。我们可以创建类的实例成员，这些成员存在于类本身不是类的实例化上。在这个例子中，我们用 static 定义 origin ，因为他是所有网格都具有的属性。每个实例想访问这个属性时，都要在前面加上类名。如同在实例属性前面加上 this. 来访问一样，我们使用 Grid. 来访问静态属性。</li>
</ul>

</div><div id="wmd-preview-section-6" class="wmd-preview-section preview-content">

<pre class="prettyprint hljs-dark"><code class="language-typescript hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-keyword">class</span> Grid{<br><span class="hljs-comment line-number">2.</span>    <span class="hljs-keyword">static</span> origin = {x: <span class="hljs-number">0</span>,y: <span class="hljs-number">0</span>};<br><span class="hljs-comment line-number">3.</span>    calculateDistanceFromOrigin(point: {x: <span class="hljs-built_in">number</span>;y: <span class="hljs-built_in">number</span>}){<br><span class="hljs-comment line-number">4.</span>        <span class="hljs-keyword">var</span> xDist = (point.x - Grid.origin.x);<br><span class="hljs-comment line-number">5.</span>        <span class="hljs-keyword">var</span> yDist = (point.y - Grid.origin.y);<br><span class="hljs-comment line-number">6.</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.sqrt(xDist * xDist + yDist * yDist) / <span class="hljs-keyword">this</span>.scale;<br><span class="hljs-comment line-number">7.</span>    }<br><span class="hljs-comment line-number">8.</span>    construstor(<span class="hljs-keyword">public</span> scale: <span class="hljs-built_in">number</span>);<br><span class="hljs-comment line-number">9.</span>}<br><span class="hljs-comment line-number">10.</span><span class="hljs-keyword">var</span> grid1 = <span class="hljs-keyword">new</span> Grid(<span class="hljs-number">1.0</span>);<br><span class="hljs-comment line-number">11.</span><span class="hljs-keyword">var</span> grid2 = <span class="hljs-keyword">new</span> Grid(<span class="hljs-number">5.0</span>);<br><span class="hljs-comment line-number">12.</span>alert(grid1.calculateDistanceFromOrigin({x: <span class="hljs-number">10</span>,y: <span class="hljs-number">10</span>}));<br><span class="hljs-comment line-number">13.</span>alert(grid2.calculateDistanceFromOrigin({x: <span class="hljs-number">10</span>,y: <span class="hljs-number">10</span>}));<br></code></pre>

<ul><li><strong>Advanced Techniques</strong>（高级技巧） <br>
<ol>
<li rel="1">Constructor functions（构造函数） <br>
When you declare a class in TypeScript, you are actually creating multiple declarations at the same time. The first is the type of the instance of the class. <br>
当你在 TypeScript 里定义类的时候，同时定义了很多东西。首先是了类的实例的类型。</li></ol></li>
</ul>

</div><div id="wmd-preview-section-7" class="wmd-preview-section preview-content">

<pre class="prettyprint hljs-dark"><code class="language-typescript hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-keyword">class</span> Greeter{<br><span class="hljs-comment line-number">2.</span>   greeting: <span class="hljs-built_in">string</span>;     <span class="hljs-comment">// 定义实例化的成员</span><br><span class="hljs-comment line-number">3.</span>   <span class="hljs-constructor"><span class="hljs-keyword">constructor</span>(message: string)</span>{   <span class="hljs-comment">// 构造函数</span><br><span class="hljs-comment line-number">4.</span>       <span class="hljs-keyword">this</span>.greeting = message;<br><span class="hljs-comment line-number">5.</span>   }<br><span class="hljs-comment line-number">6.</span>   greet(){    <span class="hljs-comment">// 定义一个函数</span><br><span class="hljs-comment line-number">7.</span>       <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello"</span> + <span class="hljs-keyword">this</span>.greeting;<br><span class="hljs-comment line-number">8.</span>   }<br><span class="hljs-comment line-number">9.</span>}<br><span class="hljs-comment line-number">10.</span><span class="hljs-keyword">var</span> greeter: Greeter;      <span class="hljs-comment">// 给 Greeter 类一个实例</span><br><span class="hljs-comment line-number">11.</span>greeter = <span class="hljs-keyword">new</span> Greeter(<span class="hljs-string">"world"</span>);  <br><span class="hljs-comment line-number">12.</span>alert(greeter.greet());<br></code></pre>

<p>Here, when we say ‘var greeter: Greeter’, we’re using Greeter as the type of instances of the class Greeter. This is almost second nature to programmers from other object-oriented languages.  <br>
当我们写 var greeter: Greeter 我们给 Greeter 类一个实例。这对于面向对象的程序猿来说是老习惯了。</p>

<p>We’re also creating another value that we call the constructor function. This is the function that is called when we ‘new’ up instances of the class. To see what this looks like in practice, let’s take a look at the JavaScript created by the above example: <br>
我们也创造了一个值当我们调用构造函数的时候。这个函数被调用当我们用 new 关键字创造函数的实例时。</p>

</div><div id="wmd-preview-section-8" class="wmd-preview-section preview-content">

<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-keyword">var</span> Greeter = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br><span class="hljs-comment line-number">2.</span>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeter</span>(<span class="hljs-params">message</span>)</span>{<br><span class="hljs-comment line-number">3.</span>        <span class="hljs-comment">// 定义一个函数  </span><br><span class="hljs-comment line-number">4.</span>        <span class="hljs-keyword">this</span>.greeting = message;<br><span class="hljs-comment line-number">5.</span>    }<br><span class="hljs-comment line-number">6.</span>    <span class="hljs-comment">// 在这个函数的原型链上定义函数</span><br><span class="hljs-comment line-number">7.</span>    Greeter.prototype.greet = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<br><span class="hljs-comment line-number">8.</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello, "</span> + <span class="hljs-keyword">this</span>.greeting;<br><span class="hljs-comment line-number">9.</span>    }<br><span class="hljs-comment line-number">10.</span>    <span class="hljs-keyword">return</span> Greeter;<br><span class="hljs-comment line-number">11.</span>})();   <span class="hljs-comment">// 自执行匿名函数</span><br><span class="hljs-comment line-number">12.</span><span class="hljs-keyword">var</span> greeter;<br><span class="hljs-comment line-number">13.</span>greeter = <span class="hljs-keyword">new</span> Greeter(<span class="hljs-string">"world"</span>);<br><span class="hljs-comment line-number">14.</span>alert(greeter.greet());<br></code></pre>

<p>Here, ‘var Greeter’ is going to be assigned the constructor function. When we call ‘new’ and run this function, we get an instance of the class. The constructor function also contains all of the static members of the class. Another way to think of each class is that there is an instance side and a static side. <br>
这里，var Greeter 是要指定的构造函数。当我们调用 new 去执行这个函数，我们获得一个类的实例化，这个构造函数也包括所有这个类的静态成员。换个角度说，我们可以说类具有实例和静态两个部分。 <br>
我们来改写这个例子：</p>

</div><div id="wmd-preview-section-9" class="wmd-preview-section preview-content">

<pre class="prettyprint hljs-dark"><code class="language-typescript hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-keyword">class</span> Greeter{<br><span class="hljs-comment line-number">2.</span>    <span class="hljs-keyword">static</span> standardGreeting = <span class="hljs-string">"Hello, there"</span>;<br><span class="hljs-comment line-number">3.</span>    greeting: <span class="hljs-built_in">string</span>;<br><span class="hljs-comment line-number">4.</span>    greet(){<br><span class="hljs-comment line-number">5.</span>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.greeting){<br><span class="hljs-comment line-number">6.</span>             <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello, "</span> + <span class="hljs-keyword">this</span>.greeting;<br><span class="hljs-comment line-number">7.</span>        } <br><span class="hljs-comment line-number">8.</span>        <span class="hljs-keyword">else</span>{<br><span class="hljs-comment line-number">9.</span>             Greeter.standardGreeting;<br><span class="hljs-comment line-number">10.</span>        }<br><span class="hljs-comment line-number">11.</span>    }<br><span class="hljs-comment line-number">12.</span>}<br><span class="hljs-comment line-number">13.</span><span class="hljs-keyword">var</span> greeter1: Greeter;<br><span class="hljs-comment line-number">14.</span>greeter1 = <span class="hljs-keyword">new</span> Greeter();<br><span class="hljs-comment line-number">15.</span>alert(greeter1.greet());<br><span class="hljs-comment line-number">16.</span><br><span class="hljs-comment line-number">17.</span><span class="hljs-keyword">var</span> greeterMaker : <span class="hljs-keyword">typeof</span> Greeter = Greeter;<br><span class="hljs-comment line-number">18.</span>greeterMaker.standardGreeting = <span class="hljs-string">"Hey there!"</span>;<br><span class="hljs-comment line-number">19.</span><span class="hljs-keyword">var</span> greeter2: Greeter = <span class="hljs-keyword">new</span> greeterMaker();<br><span class="hljs-comment line-number">20.</span>alert(greeter2.greet());<br></code></pre>

<p>In this example, ‘greeter1’ works similarly to before. We instantiate the ‘Greeter’ class, and use this object. This we have seen before. <br>
Next, we then use the class directly. Here we create a new variable called ‘greeterMaker’. This variable will hold the class itself, or said another way its constructor function. Here we use ‘typeof Greeter’, that is “give me the type of the Greeter class itself” rather than the instance type. Or, more precisely, “give me the type of the symbol called Greeter”, which is the type of the constructor function. This type will contain all of the static members of Greeter along with the constructor that creates instances of the Greeter class. We show this by using ‘new’ on ‘greeterMaker’, creating new instances of ‘Greeter’ and invoking them as before. <br>
接下来，我们直接用了这个类，我们创建了一个新的变量叫做 greeterMaker。这个变量保存了这个类或者说保存了它的构造函数。接下来用 typeof Greeter ，就是去这个类的类型，而不是实例的类型。也就是说，告诉我 Greeter 标识符的类型，也就是构造函数的类型。这个类型将包含所有的静态成员和构造函数。然后，就和前面一样，我们在 greeterMaker 上使用 new ，创建 Greet 类型的实例。</p>

<ul><li><strong>Using a class as an interface</strong>（把类当做接口使用） <br>
As we said in the previous section, a class declaration creates two things: a type representing instances of the class and a constructor function. Because classes create types, you can use them in the same places you would be able to use interfaces. <br>
如同上一节所讲的，类会创建出实例类型和构造函数，正因为类能创建出实例类型，所以在一些情况下，类可以当做接口使用。</li>
</ul>

</div><div id="wmd-preview-section-10" class="wmd-preview-section preview-content">

<pre class="prettyprint hljs-dark"><code class="language-typescript hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-keyword">class</span> Point{<br><span class="hljs-comment line-number">2.</span>    x: <span class="hljs-built_in">number</span>;<br><span class="hljs-comment line-number">3.</span>    y: <span class="hljs-built_in">number</span>;<br><span class="hljs-comment line-number">4.</span>}<br><span class="hljs-comment line-number">5.</span><span class="hljs-interface"><span class="hljs-keyword">interface</span> Point3d <span class="hljs-keyword">extends</span> Point</span>{<br><span class="hljs-comment line-number">6.</span>    z: <span class="hljs-built_in">number</span>;<br><span class="hljs-comment line-number">7.</span>}<br><span class="hljs-comment line-number">8.</span><span class="hljs-keyword">var</span> point3d: Point3d = {x: <span class="hljs-number">1</span>,y: <span class="hljs-number">2</span>,z: <span class="hljs-number">3</span>};<br></code></pre>

</div><div id="wmd-preview-section-11" class="wmd-preview-section preview-content">

<h4 id="modules">Modules</h4>

<p>This post outlines the various ways to organize your code using modules in TypeScript. We’ll be covering internal and external modules and we’ll discuss when each is appropriate and how to use them. We’ll also go over some advanced topics of how to use external modules, and address some common pitfalls when using modules in TypeScript. <br>
这篇文章介绍了 TypeScript 组织代码的各种方法。包括命名空间和模块。我们也会谈他们的高级试用场景，以及他们使用过程中常见的陷阱。</p>

<ul><li><strong>First steps</strong> <br>
Let’s start with the program we’ll be using as our example throughout this page. We’ve written a small set of simplistic string validators, like you might use when checking a user’s input on a form in a webpage or checking the format of an externally-provided data file. <br>
我们将写一个例子并且在整篇文章中都使用，我们写一个字符串验证器，假设你会使用它来验证用户的输入或者验证用户数据。</li>
</ul>

</div><div id="wmd-preview-section-12" class="wmd-preview-section preview-content">

<pre class="prettyprint hljs-dark"><code class="language-typescript hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-interface"><span class="hljs-keyword">interface</span> StringValidator</span>{<br><span class="hljs-comment line-number">2.</span>    isAcceptable(s: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>;<br><span class="hljs-comment line-number">3.</span>}<br><span class="hljs-comment line-number">4.</span><br><span class="hljs-comment line-number">5.</span><span class="hljs-keyword">var</span> lettersRegexp = <span class="hljs-regexp">/^[A-Za-z]+$/</span>;   <span class="hljs-comment">// 匹配所有英文字母</span><br><span class="hljs-comment line-number">6.</span><span class="hljs-keyword">var</span> numberRegexp = <span class="hljs-regexp">/^[0-9]+$/</span>;       <span class="hljs-comment">// 匹配所有数字</span><br><span class="hljs-comment line-number">7.</span><br><span class="hljs-comment line-number">8.</span><span class="hljs-keyword">class</span> letterOnlyValidator <span class="hljs-keyword">implements</span> StringValidator{   <span class="hljs-comment">// 声明一个类来实现这个接口</span><br><span class="hljs-comment line-number">9.</span>    isAcceptable(s: <span class="hljs-built_in">string</span>){                            <span class="hljs-comment">// 重写类中的方法</span><br><span class="hljs-comment line-number">10.</span>        <span class="hljs-keyword">return</span> lettersRegexp.test(s);                   <span class="hljs-comment">// 返回传入的参数是否匹配这个正则表达式</span><br><span class="hljs-comment line-number">11.</span>    }<br><span class="hljs-comment line-number">12.</span>}<br><span class="hljs-comment line-number">13.</span><br><span class="hljs-comment line-number">14.</span><span class="hljs-keyword">class</span> ZipCodeValidator <span class="hljs-keyword">implements</span> Vaildator{<br><span class="hljs-comment line-number">15.</span>    isAcceptable(s: <span class="hljs-built_in">string</span>){<br><span class="hljs-comment line-number">16.</span>        <span class="hljs-keyword">return</span> s.length===<span class="hljs-number">5</span> &amp;&amp; numberRegexp.test(s);<br><span class="hljs-comment line-number">17.</span>        <span class="hljs-comment">// 如果传入字符串的长度为5，测试是不是符合正则表达式，返回测试结果</span><br><span class="hljs-comment line-number">18.</span>    }<br><span class="hljs-comment line-number">19.</span>}<br><span class="hljs-comment line-number">20.</span><br><span class="hljs-comment line-number">21.</span><span class="hljs-keyword">var</span> strings = [<span class="hljs-string">'Hello'</span>,<span class="hljs-string">'98052'</span>,<span class="hljs-string">'101'</span>];<br><span class="hljs-comment line-number">22.</span><span class="hljs-comment">// [s: string] 声明为接口类型的？</span><br><span class="hljs-comment line-number">23.</span><span class="hljs-comment">// var validators 声明为对象类型，初始化为一个空对象</span><br><span class="hljs-comment line-number">24.</span><span class="hljs-keyword">var</span> validators : {[s: <span class="hljs-built_in">string</span>]: StringValidator; } = {};   <span class="hljs-comment">// ？？？</span><br><span class="hljs-comment line-number">25.</span>validators[<span class="hljs-string">'ZIP Code'</span>] = <span class="hljs-keyword">new</span> ZIPCodeValidator();<br><span class="hljs-comment line-number">26.</span>validators[<span class="hljs-string">'Letters Only'</span>] = <span class="hljs-keyword">new</span> letterOnlyValidator();<br><span class="hljs-comment line-number">27.</span><span class="hljs-comment">// show whether each string passed each validator</span><br><span class="hljs-comment line-number">28.</span>strings.forEach( s =&gt; {<br><span class="hljs-comment line-number">29.</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> validators){   <span class="hljs-comment">// 两重循环</span><br><span class="hljs-comment line-number">30.</span>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'"'</span>+ s +<span class="hljs-string">'"'</span> + (validators[name].isAcceptable(s) ? <span class="hljs-string">'matches'</span> : <span class="hljs-string">'does not match'</span>) + name);<br><span class="hljs-comment line-number">31.</span>    }<br><span class="hljs-comment line-number">32.</span>}) <br></code></pre>

<ul><li><strong>Adding Modularity</strong>（添加命名空间） <br>
As we add more validators, we’re going to want to have some kind of organization scheme so that we can keep track of our types and not worry about name collisions with other objects. Instead of putting lots of different names into the global namespace, let’s wrap up our objects into a module. <br>
In this example, we’ve moved all the Validator-related types into a module called Validation. Because we want the interfaces and classes here to be visible outside the module, we preface them with export. Conversely, the variables lettersRegexp and numberRegexp are implementation details, so they are left unexported and will not be visible to code outside the module. In the test code at the bottom of the file, we now need to qualify the names of the types when used outside the module, e.g. Validation.LettersOnlyValidator. <br>
随着更多验证器的加入，我们需要一种手段来组织代码，以便在记录他们类型的同时还不担心和其他对象产生命名冲突，因此，我们把验证器放到一个命名空间内而不是全局命名空间下。 <br>
在这个例子中，我们把所有验证器相关的类型都放到一个叫做 Validator 的命名空间中。因为我们想让这些接口和类在命名空间之外也是可访问的，所以需要使用 export 。相反的，变量 lettersRegexp 和 numberRegexp 是实现的细节，不需要导出，因此他们在命名空间之外的地方是不能访问的。在文末尾的测试代码中，在我们在命名空间外访问时，我们需要验证类型的名称。就像是 Validation.LettersOnlyValidator 。</li>
</ul>

</div><div id="wmd-preview-section-13" class="wmd-preview-section preview-content">

<pre class="prettyprint hljs-dark"><code class="language-typescript hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-module"><span class="hljs-keyword">module</span> Validation </span>{    <span class="hljs-comment">// 定义一个命名空间</span><br><span class="hljs-comment line-number">2.</span>    <span class="hljs-keyword">export</span> <span class="hljs-interface"><span class="hljs-keyword">interface</span> StringValidator</span>{   <span class="hljs-comment">// 接口在命名空间之外也是可显示的</span><br><span class="hljs-comment line-number">3.</span>        isAcceptable(s: stirng): <span class="hljs-built_in">boolean</span>;<br><span class="hljs-comment line-number">4.</span>    }<br><span class="hljs-comment line-number">5.</span>    <span class="hljs-keyword">var</span> lettersRegexp = <span class="hljs-regexp">/^[A-Za-z]+$/</span>;<br><span class="hljs-comment line-number">6.</span>    <span class="hljs-keyword">var</span> numberRegexp = <span class="hljs-regexp">/^[0-9]+$/</span>;<br><span class="hljs-comment line-number">7.</span>    <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> letterOnlyValidator <span class="hljs-keyword">implements</span> StringValidator{<br><span class="hljs-comment line-number">8.</span>        isAcceptable(s: <span class="hljs-built_in">string</span>){<br><span class="hljs-comment line-number">9.</span>            <span class="hljs-keyword">return</span> lettersRegexp.test(s);  <span class="hljs-comment">// 正则表达式是否匹配s</span><br><span class="hljs-comment line-number">10.</span>        }<br><span class="hljs-comment line-number">11.</span>    }<br><span class="hljs-comment line-number">12.</span>    <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ZipCodeValidator <span class="hljs-keyword">implements</span> StringValidator{<br><span class="hljs-comment line-number">13.</span>        isAcceptable(s: <span class="hljs-built_in">string</span>){<br><span class="hljs-comment line-number">14.</span>            <span class="hljs-keyword">return</span> s.length===<span class="hljs-number">5</span> &amp;&amp; numberRegexp.test(s);<br><span class="hljs-comment line-number">15.</span>        }<br><span class="hljs-comment line-number">16.</span>    }<br><span class="hljs-comment line-number">17.</span>}<br><span class="hljs-comment line-number">18.</span><span class="hljs-keyword">var</span> strings = [<span class="hljs-string">'Hello'</span>,<span class="hljs-string">'12345'</span>,<span class="hljs-string">'123'</span>];<br><span class="hljs-comment line-number">19.</span><span class="hljs-keyword">var</span> validators = {[s: <span class="hljs-built_in">string</span>]: Validation.StringValidator; } = {};<br><span class="hljs-comment line-number">20.</span>validators[<span class="hljs-string">'ZIP code'</span>] = <span class="hljs-keyword">new</span> Validation.ZIPCodeValidator();<br><span class="hljs-comment line-number">21.</span>validators[<span class="hljs-string">'Letters only'</span>] = <span class="hljs-keyword">new</span> Validation.LettersOnlyValidator();<br><span class="hljs-comment line-number">22.</span>strings.forEach(s =&gt; {<br><span class="hljs-comment line-number">23.</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> validators){<br><span class="hljs-comment line-number">24.</span>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"'"</span>+ s +<span class="hljs-string">"'"</span> + (vallidators[name].isAcceptable(s) ? <span class="hljs-string">'matches'</span> : <span class="hljs-string">'does not match'</span>) + name);<br><span class="hljs-comment line-number">25.</span>    }<br><span class="hljs-comment line-number">26.</span>})  <br></code></pre>

<blockquote>
  <p>将内容都放到一个命名空间里，在需要使用时带上命名空间的前缀。</p>
</blockquote>

<ul><li><strong>Splitting Across Files</strong> 分离到多文件 <br>
As our application grows, we’ll want to split the code across multiple files to make it easier to maintain. <br>
Here, we’ve split our Validation module across many files. Even though the files are separate, they can each contribute to the same module and can be consumed as if they were all defined in one place. Because there are dependencies between files, we’ve added reference tags to tell the compiler about the relationships between the files. Our test code is otherwise unchanged. <br>
当我们的应用越来越大时，我们需要将代码分离到不同的文件以便于维护。 <br>
这里，我们分开 Validation  命名空间在不同的文件。尽管这些文件是分开的，它们仍是同一个命名空间。并且在使用是就像是它们是在一个文件中定义的一样。因为不同文件之间存在依赖关系，所以我们用标签来说明它们之间的关联。我们的测试代码保持不变。 <br>
<ol>
<li rel="1">Multi-file internal modules（多文件中的命名空间）</li></ol></li>
</ul>

</div><div id="wmd-preview-section-14" class="wmd-preview-section preview-content">

<pre class="prettyprint hljs-dark"><code class="language-typescript hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-comment">// Validation.ts</span><br><span class="hljs-comment line-number">2.</span><span class="hljs-module"><span class="hljs-keyword">module</span> Validation </span>{<br><span class="hljs-comment line-number">3.</span>    <span class="hljs-keyword">export</span> <span class="hljs-interface"><span class="hljs-keyword">interface</span> StringValidator </span>{<br><span class="hljs-comment line-number">4.</span>        isAcceptable(s: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span>;<br><span class="hljs-comment line-number">5.</span>    }<br><span class="hljs-comment line-number">6.</span>}<br><span class="hljs-comment line-number">7.</span><span class="hljs-comment">// LettersOnlyValidator.ts</span><br><span class="hljs-comment line-number">8.</span><span class="hljs-comment">/// &lt;reference path="Validation.ts" /&gt;</span><br><span class="hljs-comment line-number">9.</span><span class="hljs-module"><span class="hljs-keyword">module</span> Validation </span>{<br><span class="hljs-comment line-number">10.</span>    <span class="hljs-keyword">var</span> lettersRegexp = <span class="hljs-regexp">/^[A-Za-z]+$/</span>;<br><span class="hljs-comment line-number">11.</span>    <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> LettersOnlyValidator <span class="hljs-keyword">implements</span> StringValidator {<br><span class="hljs-comment line-number">12.</span>        isAcceptable(s: <span class="hljs-built_in">string</span>) {<br><span class="hljs-comment line-number">13.</span>            <span class="hljs-keyword">return</span> lettersRegexp.test(s);<br><span class="hljs-comment line-number">14.</span>        }<br><span class="hljs-comment line-number">15.</span>    }<br><span class="hljs-comment line-number">16.</span>}<br><span class="hljs-comment line-number">17.</span><span class="hljs-comment">// ZipCodeValidator.ts</span><br><span class="hljs-comment line-number">18.</span><span class="hljs-comment">/// &lt;reference path="Validation.ts" /&gt;</span><br><span class="hljs-comment line-number">19.</span><span class="hljs-module"><span class="hljs-keyword">module</span> Validation </span>{<br><span class="hljs-comment line-number">20.</span>    <span class="hljs-keyword">var</span> numberRegexp = <span class="hljs-regexp">/^[0-9]+$/</span>;<br><span class="hljs-comment line-number">21.</span>    <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ZipCodeValidator <span class="hljs-keyword">implements</span> StringValidator {<br><span class="hljs-comment line-number">22.</span>        isAcceptable(s: <span class="hljs-built_in">string</span>) {<br><span class="hljs-comment line-number">23.</span>            <span class="hljs-keyword">return</span> s.length === <span class="hljs-number">5</span> &amp;&amp; numberRegexp.test(s);<br><span class="hljs-comment line-number">24.</span>        }<br><span class="hljs-comment line-number">25.</span>    }<br><span class="hljs-comment line-number">26.</span>}<br><span class="hljs-comment line-number">27.</span><span class="hljs-comment">// Test.ts</span><br><span class="hljs-comment line-number">28.</span><span class="hljs-comment">/// &lt;reference path="Validation.ts" /&gt;</span><br><span class="hljs-comment line-number">29.</span><span class="hljs-comment">/// &lt;reference path="LettersOnlyValidator.ts" /&gt;</span><br><span class="hljs-comment line-number">30.</span><span class="hljs-comment">/// &lt;reference path="ZipCodeValidator.ts" /&gt;</span><br><span class="hljs-comment line-number">31.</span><br><span class="hljs-comment line-number">32.</span><span class="hljs-comment">// Some samples to try</span><br><span class="hljs-comment line-number">33.</span><span class="hljs-keyword">var</span> strings = [<span class="hljs-string">'Hello'</span>, <span class="hljs-string">'98052'</span>, <span class="hljs-string">'101'</span>];<br><span class="hljs-comment line-number">34.</span><span class="hljs-comment">// Validators to use</span><br><span class="hljs-comment line-number">35.</span><span class="hljs-keyword">var</span> validators: { [s: <span class="hljs-built_in">string</span>]: Validation.StringValidator; } = {};<br><span class="hljs-comment line-number">36.</span>validators[<span class="hljs-string">'ZIP code'</span>] = <span class="hljs-keyword">new</span> Validation.ZipCodeValidator();<br><span class="hljs-comment line-number">37.</span>validators[<span class="hljs-string">'Letters only'</span>] = <span class="hljs-keyword">new</span> Validation.LettersOnlyValidator();<br><span class="hljs-comment line-number">38.</span><span class="hljs-comment">// Show whether each string passed each validator</span><br><span class="hljs-comment line-number">39.</span>strings.forEach(s =&gt; {<br><span class="hljs-comment line-number">40.</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> validators) {<br><span class="hljs-comment line-number">41.</span>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'"'</span> + s + <span class="hljs-string">'" '</span> + (validators[name].isAcceptable(s) ? <span class="hljs-string">' matches '</span> : <span class="hljs-string">' does not match '</span>) + name);<br><span class="hljs-comment line-number">42.</span>    }<br><span class="hljs-comment line-number">43.</span>});<br></code></pre>

<p>Once there are multiple files involved, we’ll need to make sure all of the compiled code gets loaded. There are two ways of doing this. <br>
一旦有多个文件，我们需要确保所有编译后的代码都被加载了，有两种方法。 <br>
第一种方式，把所有的输入文件编译为一个输出文件，需要使用–outFile标记：</p>

</div><div id="wmd-preview-section-15" class="wmd-preview-section preview-content">

<pre class="prettyprint hljs-dark"><code class="language-typescript hljs"><span class="hljs-comment line-number">1.</span>tsc --out sample.js Test.ts<br></code></pre>

<p>编译器会根据源码里的引用标签自动地对输出进行排序。你也可以单独地指定每个文件。</p>

</div><div id="wmd-preview-section-16" class="wmd-preview-section preview-content">

<pre class="prettyprint hljs-dark"><code class="language-typescript hljs"><span class="hljs-comment line-number">1.</span>tsc --out sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts<br></code></pre>

<p>第二种方式，我们可以编译每一个文件（默认方式），那么每个源文件都会对应生成一个JavaScript文件。 然后，在页面上通过 script 标签把所有生成的JavaScript文件按正确的顺序引进来，比如：</p>

</div><div id="wmd-preview-section-17" class="wmd-preview-section preview-content">

<pre class="prettyprint hljs-dark"><code class="language-typescript hljs"><span class="hljs-comment line-number">1.</span>    &lt;script src=<span class="hljs-string">"Validation.js"</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">"text/javascript"</span> /&gt;<br><span class="hljs-comment line-number">2.</span>    &lt;script src=<span class="hljs-string">"LettersOnlyValidator.js"</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">"text/javascript"</span> /&gt;<br><span class="hljs-comment line-number">3.</span>    &lt;script src=<span class="hljs-string">"ZipCodeValidator.js"</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">"text/javascript"</span> /&gt;<br><span class="hljs-comment line-number">4.</span>    &lt;script src=<span class="hljs-string">"Test.js"</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">"text/javascript"</span> /&gt;<br></code></pre>

<blockquote>
  <p>将每一个 TypeScript 编译为 JavaScript 文件，这样也可以学到 JavaScript 啊。自己编译完学习它的写法，闭包原型链，this，作用域。</p>
</blockquote>

<ul><li><strong>Going External</strong>（别名） <br>
TypeScript also has the concept of an external module. External modules are used in two cases: node.js and require.js. Applications not using node.js or require.js do not need to use external modules and can best be organized using the internal module concept outlined above. <br>
TypeScript 也有外部模块的概念。外部模块在两种情况下使用：node.js 和 require.js，应用不使用 node.js 或者 require.js 不用使用外部模块并且可以用内部命名空间被搭好。</li>
</ul>

<blockquote>
  <p>竟然在面试的时候说过学习 JavaScript 是把 JavaScript 高级程序设计的书看了两遍，现在想起来好搞笑。。 <br>
  不用说学过什么新的东西，直接讲做出了什么就行了。就是学一点就要去做东西，这样才能遇到问题。</p>
</blockquote>

<p><strong>模块后面还有很多东西只是看了一遍，并没有仔细学习</strong></p>

</div><div id="wmd-preview-section-18" class="wmd-preview-section preview-content">

<h4 id="函数">函数</h4>

<ul><li>书写完整函数类型</li>
</ul>

</div><div id="wmd-preview-section-19" class="wmd-preview-section preview-content">

<pre class="prettyprint hljs-dark"><code class="language-typescript hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-comment">// 上面一行参数类型和返回值类型都是必须的</span><br><span class="hljs-comment line-number">2.</span><span class="hljs-comment">// 下面一行一般不写返回值类型，如果写了上面参数类型也可以不写</span><br><span class="hljs-comment line-number">3.</span><span class="hljs-keyword">var</span> myAdd: (x:<span class="hljs-built_in">number</span>, y:<span class="hljs-built_in">number</span>) =&gt; <span class="hljs-built_in">number</span> = <br><span class="hljs-comment line-number">4.</span>    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>{ <span class="hljs-keyword">return</span> x+y; };<br></code></pre>

<ul><li>可选参数和默认参数 <br>
传递给一个函数的参数个数必须与函数期望的参数个数一致。 <br>
JavaScript里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是undefined。 在TypeScript里我们可以在参数名旁使用?实现可选参数的功能。 比如，我们想让last name是可选的：</li>
</ul>

</div><div id="wmd-preview-section-20" class="wmd-preview-section preview-content">

<pre class="prettyprint hljs-dark"><code class="language-typescript hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildName</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span>, lastName?: <span class="hljs-built_in">string</span></span>) </span>{<br><span class="hljs-comment line-number">2.</span>    <span class="hljs-keyword">if</span> (lastName)<br><span class="hljs-comment line-number">3.</span>        <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">" "</span> + lastName;<br><span class="hljs-comment line-number">4.</span>    <span class="hljs-keyword">else</span><br><span class="hljs-comment line-number">5.</span>        <span class="hljs-keyword">return</span> firstName;<br><span class="hljs-comment line-number">6.</span>}<br><span class="hljs-comment line-number">7.</span><br><span class="hljs-comment line-number">8.</span><span class="hljs-keyword">var</span> result1 = buildName(<span class="hljs-string">"Bob"</span>);  <span class="hljs-comment">//works correctly now</span><br><span class="hljs-comment line-number">9.</span><span class="hljs-keyword">var</span> result2 = buildName(<span class="hljs-string">"Bob"</span>, <span class="hljs-string">"Adams"</span>, <span class="hljs-string">"Sr."</span>);  <span class="hljs-comment">//error, too many parameters</span><br><span class="hljs-comment line-number">10.</span><span class="hljs-keyword">var</span> result3 = buildName(<span class="hljs-string">"Bob"</span>, <span class="hljs-string">"Adams"</span>);  <span class="hljs-comment">//ah, just right</span><br></code></pre>

<p>可选参数必须跟在必须参数后面。 如果上例我们想让first name是可选的，那么就必须调整它们的位置，把first name放在后面。 <br>
在TypeScript里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是undefined时。 它们叫做有默认初始化值的参数。 让我们修改上例，把last name的默认值设置为”Smith”。</p>

</div><div id="wmd-preview-section-21" class="wmd-preview-section preview-content">

<pre class="prettyprint hljs-dark"><code class="language-typescript hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildName</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span>, lastName = "Smith"</span>) </span>{<br><span class="hljs-comment line-number">2.</span>    <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">" "</span> + lastName;<br><span class="hljs-comment line-number">3.</span>}<br><span class="hljs-comment line-number">4.</span><br><span class="hljs-comment line-number">5.</span><span class="hljs-keyword">var</span> result1 = buildName(<span class="hljs-string">"Bob"</span>);  <span class="hljs-comment">//works correctly now, also</span><br><span class="hljs-comment line-number">6.</span><span class="hljs-keyword">var</span> result2 = buildName(<span class="hljs-string">"Bob"</span>, <span class="hljs-string">"Adams"</span>, <span class="hljs-string">"Sr."</span>);  <span class="hljs-comment">//error, too many parameters</span><br><span class="hljs-comment line-number">7.</span><span class="hljs-keyword">var</span> result3 = buildName(<span class="hljs-string">"Bob"</span>, <span class="hljs-string">"Adams"</span>);  <span class="hljs-comment">//ah, just right</span><br></code></pre>

<ul><li>剩余参数 <br>
剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（…）后面给定的名字，你可以在函数体内使用这个数组。</li>
<li>Lambda表达式和使用this <br>
我们把函数表达式变为使用lambda表达式（ () =&gt; {} ）。 这样就会在函数创建的时候就指定了‘this’值，而不是在函数调用的时候。</li>
</ul>

</div><div id="wmd-preview-section-88" class="wmd-preview-section preview-content">

<pre class="prettyprint hljs-dark"><code class="language-typescript hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-keyword">var</span> deck = {<br><span class="hljs-comment line-number">2.</span>    suits: [<span class="hljs-string">"hearts"</span>, <span class="hljs-string">"spades"</span>, <span class="hljs-string">"clubs"</span>, <span class="hljs-string">"diamonds"</span>],<br><span class="hljs-comment line-number">3.</span>    cards: <span class="hljs-built_in">Array</span>(<span class="hljs-number">52</span>),<br><span class="hljs-comment line-number">4.</span>    createCardPicker: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<br><span class="hljs-comment line-number">5.</span>        <span class="hljs-comment">// Notice: the line below is now a lambda, allowing us to capture 'this' earlier</span><br><span class="hljs-comment line-number">6.</span>        <span class="hljs-keyword">return</span> () =&gt; {<br><span class="hljs-comment line-number">7.</span>            <span class="hljs-keyword">var</span> pickedCard = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">52</span>);<br><span class="hljs-comment line-number">8.</span>            <span class="hljs-keyword">var</span> pickedSuit = <span class="hljs-built_in">Math</span>.floor(pickedCard / <span class="hljs-number">13</span>);<br><span class="hljs-comment line-number">9.</span><br><span class="hljs-comment line-number">10.</span>            <span class="hljs-keyword">return</span> {suit: <span class="hljs-keyword">this</span>.suits[pickedSuit], card: pickedCard % <span class="hljs-number">13</span>};<br><span class="hljs-comment line-number">11.</span>        }<br><span class="hljs-comment line-number">12.</span>    }<br><span class="hljs-comment line-number">13.</span>}<br><span class="hljs-comment line-number">14.</span><br><span class="hljs-comment line-number">15.</span><span class="hljs-keyword">var</span> cardPicker = deck.createCardPicker();<br><span class="hljs-comment line-number">16.</span><span class="hljs-keyword">var</span> pickedCard = cardPicker();<br><span class="hljs-comment line-number">17.</span><br><span class="hljs-comment line-number">18.</span>alert(<span class="hljs-string">"card: "</span> + pickedCard.card + <span class="hljs-string">" of "</span> + pickedCard.suit);<br><span class="hljs-comment line-number">19.</span><br></code></pre>

<ul><li>重载(没看完) <br>
JavaScript本身是个动态语言。 JavaScript里函数根据传入不同的参数而返回不同类型的数据是很常见的。 <br>
为了让编译器能够选择正确的检查类型，它与JavaScript里的处理流程相似。 它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面。 <br>
注意，function pickCard(x): any并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象另一个接收数字。 以其它参数调用pickCard会产生错误。</li>
</ul></div><div id="wmd-preview-section-footnotes" class="preview-content"></div></div></div></body></html>
